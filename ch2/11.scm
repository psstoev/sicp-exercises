;; Exercise 2.11: In passing, Ben also cryptically comments: “By
;; testing the signs of the endpoints of the intervals, it is possible
;; to break mul-interval into nine cases, only one of which requires
;; more than two multiplications.” Rewrite this procedure using Ben’s
;; suggestion.

;; Answer:

;; This version should be more readable:
;; (define (mul-interval x y)
;;   (let ((a (lower-bound x))
;;         (b (upper-bound x))
;;         (c (lower-bound y))
;;         (d (upper-bound y)))
;;     (cond ((and (negative? b) (negative? d))
;;            (make-interval (* b d) (* a c)))
;;           ((and (negative? b) (negative? c) (positive? d))
;;            (make-interval (* a d) (* a c)))
;;           ((and (negative? b) (positive? c))
;;            (make-interval (* a d) (* b c)))
;;           ((and (negative? a) (positive? b) (negative? d))
;;            (make-interval (* b c) (* a c)))
;;           ((and (negative? a) (positive? b) (positive? c))
;;            (make-interval (* a d) (* b d)))
;;           ((and (negative? a) (positive? b) (negative? c) (positive? d))
;;            (let ((p1 (* a c))
;;                  (p2 (* a d))
;;                  (p3 (* b c))
;;                  (p4 (* b d)))
;;              (make-interval (min p1 p2 p3 p4)
;;                             (max p1 p2 p3 p4))))
;;           ((and (positive? a) (negative? d))
;;            (make-interval (* b c) (* a d)))
;;           ((and (positive? a) (negative? c) (positive? d))
;;            (make-interval (* c b) (* b d)))
;;           ((and (positive? a) (positive? c))
;;            (make-interval (* a c) (* b d))))))

;; And this should be slightly faster (only up to 4 sign checks):
(define (mul-interval x y)
  (let ((a (lower-bound x))
        (b (upper-bound x))
        (c (lower-bound y))
        (d (upper-bound y)))
    (if (negative? b)
        (if (negative? d)
            (make-interval (* b d) (* a c))
            (if (negative? c)
                (make-interval (* a d) (* a c))
                (make-interval (* a d) (* b c))))
        (if (negative? a)
            (if (negative? d)
                (make-interval (* b c) (* a c))
                (if (negative? c)
                    (let ((p1 (* a c))
                          (p2 (* a d))
                          (p3 (* b c))
                          (p4 (* b d)))
                      (make-interval (min p1 p2 p3 p4)
                                     (max p1 p2 p3 p4)))
                    (make-interval (* a d) (* b d))))
            (if (negative? d)
                (make-interval (* b c) (* a d))
                (if (negative? c)
                    (make-interval (* b c) (* b d))
                    (make-interval (* a c) (* b d))))))))

(define (positive? x) (>= x 0))

(define (negative? x) (<= x 0))

(define (make-interval a b) (cons a b))

(define (lower-bound x) (car x))

(define (upper-bound x) (cdr x))

;; Test it:
(mul-interval (make-interval -5 -2)
              (make-interval -3 -1))
;; (2 . 15)
(mul-interval (make-interval -5 -2)
              (make-interval -3 1))
;; (-5 . 15)
(mul-interval (make-interval -5 -2)
              (make-interval 1 3))
;; (-15 . -2)
(mul-interval (make-interval -5 2)
              (make-interval -3 -1))
;; (-6 . 15)
(mul-interval (make-interval -5 2)
              (make-interval -3 1))
;; (-6 . 15)
(mul-interval (make-interval 2 3)
              (make-interval -8 -3))
;; (-24 . -6)
(mul-interval (make-interval 2 3)
              (make-interval -3 8))
;; (-9 . 24)
(mul-interval (make-interval 2 3)
              (make-interval 3 8))
;; (6 . 24)
(mul-interval (make-interval -2 3)
              (make-interval -8 -3))
;; (-24 . 16)
(mul-interval (make-interval 0 3)
              (make-interval -4 1))
;; (-12 . 3)
